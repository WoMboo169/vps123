#!/bin/bash
set -euo pipefail

# ========================================================================
# Enhanced Multi-VM Manager (QEMU/KVM & Cloud-Init)
# ========================================================================
# Base Code Credit: HOPINGBOYZ & EDIT BY NOBITA
# Completed & Verified by Gemini
# Used for safe, authorized, educational, and testing purposes only.

# --- Global Configuration & Variables ---
VM_DIR="$HOME/qemu_vms"

# OS_OPTIONS: OS_NAME="OS_TYPE|CODENAME|IMG_URL|DEFAULT_HOSTNAME|DEFAULT_USERNAME|DEFAULT_PASSWORD"
declare -A OS_OPTIONS=(
    ["Ubuntu 22.04 LTS (Jammy)"]="ubuntu|jammy|https://cloud-images.ubuntu.com/jammy/current/jammy-server-cloudimg-amd64.img|ubuntu-vm|ubuntu|ubuntu"
    ["Debian 12 (Bookworm)"]="debian|bookworm|https://cloud.debian.org/images/cloud/bookworm/latest/debian-12-generic-amd64.qcow2|debian-vm|debian|debian"
    ["Alpine Linux Edge"]="alpine|edge|https://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/x86_64/alpine-virt-3.19.1-x86_64.iso|alpine-vm|alpine|alpine"
)

# --- Utility Functions ---

# Function to display header
display_header() {
    clear
    cat << "EOF"
========================================================================
                       _ _     _                 
                      | (_)   | |                
                      | |_ ___| |__  _ __  _   _ 
                  _   | | / __| '_ \| '_ \| | | |
                 | |__| | \__ \ | | | | | | |_| |
                  \____/|_|___/_| |_|_| |_|\__,_| 
                                                                  
        QEMU/KVM VIRTUAL MACHINE MANAGER | HOPINGBOYZ & NOBITA
========================================================================
EOF
    echo
}

# Function to display colored output with emojis
print_status() {
    local type=$1
    local message=$2
    
    # ANSI Color Codes: 31=Red, 32=Green, 33=Yellow, 34=Blue, 36=Cyan, 0=Reset
    case $type in
        "INFO") echo -e "\033[1;34mðŸ“‹ [INFO]\033[0m $message" ;;
        "WARN") echo -e "\033[1;33mâš ï¸  [WARN]\033[0m $message" ;;
        "ERROR") echo -e "\033[1;31mâŒ [ERROR]\033[0m $message" ;;
        "SUCCESS") echo -e "\033[1;32mâœ… [SUCCESS]\033[0m $message" ;;
        "INPUT") echo -e "\033[1;36mðŸŽ¯ [INPUT]\033[0m $message" ;;
        *) echo "[$type] $message" ;;
    esac
}

# ========================================================================
# --- CORE VM MANAGEMENT FUNCTIONS ---
# ========================================================================

# Function to check if image file is locked
check_image_lock() {
    local img_file=$1
    local vm_name=$2
    
    # Check if QEMU is already using this image
    if lsof "$img_file" 2>/dev/null | grep -q qemu-system; then
        print_status "WARN" "ðŸ”’ Image file $img_file is already in use by another QEMU process"
        
        # Find the process ID
        local pid=$(lsof "$img_file" 2>/dev/null | grep qemu-system | awk '{print $2}' | head -1)
        if [[ -n "$pid" ]]; then
            print_status "INFO" "ðŸ” Process ID using the image: $pid"
            
            # Check if it's our own VM
            if ps -p "$pid" -o cmd= | grep -q "$vm_name"; then
                print_status "INFO" "ðŸ¤” This appears to be the same VM already running"
                read -p "$(print_status "INPUT" "ðŸ”„ Kill existing process and restart? (y/N): ")" kill_choice
                if [[ "$kill_choice" =~ ^[Yy]$ ]]; then
                    kill "$pid" 2>/dev/null
                    sleep 2
                    if kill -0 "$pid" 2>/dev/null; then
                        kill -9 "$pid" 2>/dev/null
                        print_status "WARN" "âš ï¸  Forcefully terminated process $pid"
                    fi
                    return 0
                else
                    return 1
                fi
            else
                print_status "ERROR" "ðŸš« Another QEMU instance is using this image"
                return 1
            fi
        fi
        return 1
    fi
    
    # Check for lock files
    local lock_file="${img_file}.lock"
    if [[ -f "$lock_file" ]]; then
        print_status "WARN" "ðŸ”’ Lock file found: $lock_file"
        
        # Check if lock file is stale (older than 5 minutes)
        if [[ $(find "$lock_file" -mmin +5 2>/dev/null) ]]; then
            print_status "WARN" "â° Lock file appears stale (older than 5 minutes)"
            read -p "$(print_status "INPUT" "ðŸ—‘ï¸  Remove stale lock file? (y/N): ")" remove_lock
            if [[ "$remove_lock" =~ ^[Yy]$ ]]; then
                rm -f "$lock_file"
                print_status "SUCCESS" "âœ… Removed stale lock file"
                return 0
            else
                return 1
            fi
        fi
        return 1
    fi
    return 0
}

# Function to validate input
validate_input() {
    local type=$1
    local value=$2
    
    case $type in
        "number")
            if ! [[ "$value" =~ ^[0-9]+$ ]]; then
                print_status "ERROR" "âŒ Must be a number"
                return 1
            fi
            ;;
        "size")
            if ! [[ "$value" =~ ^[0-9]+[GgMm]$ ]]; then
                print_status "ERROR" "âŒ Must be a size with unit (e.g., 100G, 512M)"
                return 1
            fi
            ;;
        "port")
            if ! [[ "$value" =~ ^[0-9]+$ ]] || [ "$value" -lt 1025 ] || [ "$value" -gt 65535 ]; then
                print_status "ERROR" "âŒ Must be a valid non-privileged port number (1025-65535)"
                return 1
            fi
            ;;
        "name")
            if ! [[ "$value" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                print_status "ERROR" "âŒ VM name can only contain letters, numbers, hyphens, and underscores"
                return 1
            fi
            ;;
        "username")
            if ! [[ "$value" =~ ^[a-z_][a-z0-9_-]*$ ]]; then
                print_status "ERROR" "âŒ Username must start with a letter or underscore, and contain only letters, numbers, hyphens, and underscores"
                return 1
            fi
            ;;
    esac
    return 0
}

# Function to check dependencies
check_dependencies() {
    local deps=("qemu-system-x86_64" "wget" "cloud-localds" "qemu-img" "lsof" "openssl")
    local missing_deps=()
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_deps+=("$dep")
        fi
    done
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        print_status "ERROR" "ðŸ”§ Missing dependencies: ${missing_deps[*]}"
        print_status "INFO" "ðŸ’¡ On Ubuntu/Debian, try: sudo apt install qemu-system cloud-image-utils wget lsof openssl"
        exit 1
    fi
}

# Function to cleanup temporary files
cleanup() {
    # Ensure cleanup is run in the main script's working directory, not VM_DIR
    if [ -f "user-data" ]; then rm -f "user-data"; fi
    if [ -f "meta-data" ]; then rm -f "meta-data"; fi
}

# Function to get all VM configurations
get_vm_list() {
    find "$VM_DIR" -maxdepth 1 -name "*.conf" -exec basename {} .conf \; 2>/dev/null | sort
}

# Function to load VM configuration
load_vm_config() {
    local vm_name=$1
    local config_file="$VM_DIR/$vm_name.conf"
    
    if [[ -f "$config_file" ]]; then
        # Clear previous variables
        unset VM_NAME OS_TYPE CODENAME IMG_URL HOSTNAME USERNAME PASSWORD
        unset DISK_SIZE MEMORY CPUS SSH_PORT GUI_MODE PORT_FORWARDS IMG_FILE SEED_FILE CREATED
        
        # Source the config file to load variables globally
        # shellcheck disable=SC1090
        source "$config_file"
        return 0
    else
        print_status "ERROR" "ðŸ“‚ Configuration for VM '$vm_name' not found"
        return 1
    fi
}

# Function to save VM configuration
save_vm_config() {
    local config_file="$VM_DIR/$VM_NAME.conf"
    
    # Check if critical variables are set
    if [[ -z "$VM_NAME" || -z "$IMG_FILE" ]]; then
        print_status "ERROR" "âš ï¸  Cannot save config: Critical variables are missing."
        return 1
    fi
    
    cat > "$config_file" <<EOF
VM_NAME="$VM_NAME"
OS_TYPE="$OS_TYPE"
CODENAME="$CODENAME"
IMG_URL="$IMG_URL"
HOSTNAME="$HOSTNAME"
USERNAME="$USERNAME"
PASSWORD="$PASSWORD"
DISK_SIZE="$DISK_SIZE"
MEMORY="$MEMORY"
CPUS="$CPUS"
SSH_PORT="$SSH_PORT"
GUI_MODE="$GUI_MODE"
PORT_FORWARDS="$PORT_FORWARDS"
IMG_FILE="$IMG_FILE"
SEED_FILE="$SEED_FILE"
CREATED="$CREATED"
EOF
    
    print_status "SUCCESS" "ðŸ’¾ Configuration saved to $config_file"
}

# Function to setup VM image (Download, Resize, Cloud-Init)
setup_vm_image() {
    print_status "INFO" "ðŸ“¥ Downloading and preparing image..."
    
    mkdir -p "$VM_DIR"
    
    # 1. Check/Download Image
    if [[ -f "$IMG_FILE" ]]; then
        print_status "INFO" "âœ… Image file already exists. Skipping download."
    else
        print_status "INFO" "ðŸŒ Downloading image from $IMG_URL..."
        if ! wget --progress=bar:force "$IMG_URL" -O "$IMG_FILE.tmp"; then
            print_status "ERROR" "âŒ Failed to download image from $IMG_URL"
            exit 1
        fi
        mv "$IMG_FILE.tmp" "$IMG_FILE"
    fi
    
    # 2. Resize the disk image
    print_status "INFO" "ðŸ’¾ Resizing disk image to $DISK_SIZE..."
    if ! qemu-img resize "$IMG_FILE" "$DISK_SIZE" 2>/dev/null; then
        # If resize fails (e.g., base image is read-only), try creating a new image from it
        print_status "WARN" "âš ï¸  Failed to directly resize image. Creating a new Cow2 image based on it..."
        local temp_new_img="$VM_DIR/$VM_NAME.qcow2"
        # Check if the existing file is the one we should be copying from
        if [[ "$IMG_FILE" != "$temp_new_img" ]]; then
            rm -f "$temp_new_img"
            if qemu-img create -f qcow2 -b "$IMG_FILE" "$temp_new_img" "$DISK_SIZE" 2>/dev/null; then
                IMG_FILE="$temp_new_img"                   # Use the new cow image
                print_status "SUCCESS" "âœ… Created CoW image for $VM_NAME"
            else
                print_status "ERROR" "âŒ Fatal: Could not resize or create Cow2 image. Disk setup failed."
                exit 1
            fi
        fi
    fi

    # 3. cloud-init configuration files
    local HASHED_PASSWORD
    HASHED_PASSWORD=$(openssl passwd -6 "$PASSWORD" | tr -d '\n')
    
    cat > user-data <<EOF
#cloud-config
hostname: $HOSTNAME
ssh_pwauth: true
disable_root: false
users:
  - name: $USERNAME
    sudo: ALL=(ALL) NOPASSWD:ALL
    shell: /bin/bash
    password: $HASHED_PASSWORD
chpasswd:
  list: |
    root:$PASSWORD
    $USERNAME:$PASSWORD
  expire: false
EOF

    cat > meta-data <<EOF
instance-id: iid-$VM_NAME
local-hostname: $HOSTNAME
EOF

    # 4. Create seed image
    # Note: Cloud-localds expects to run in the directory where user-data/meta-data exist.
    if ! cloud-localds "$SEED_FILE" user-data meta-data; then
        print_status "ERROR" "âŒ Failed to create cloud-init seed image"
        exit 1
    fi
    
    print_status "SUCCESS" "ðŸŽ‰ VM '$VM_NAME' image prepared successfully."
}

# Function to create new VM
create_new_vm() {
    print_status "INFO" "ðŸ†• Creating a new VM"
    
    # OS Selection
    print_status "INFO" "ðŸŒ Select an OS to set up:"
    local os_options=()
    local i=1
    for os in "${!OS_OPTIONS[@]}"; do
        echo "  $i) $os"
        os_options[$i]="$os"
        ((i++))
    done
    
    while true; do
        read -p "$(print_status "INPUT" "ðŸŽ¯ Enter your choice (1-${#OS_OPTIONS[@]}): ")" choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le ${#OS_OPTIONS[@]} ]; then
            local os="${os_options[$choice]}"
            # shellcheck disable=SC2206
            IFS='|' read -r OS_TYPE CODENAME IMG_URL DEFAULT_HOSTNAME DEFAULT_USERNAME DEFAULT_PASSWORD <<< "${OS_OPTIONS[$os]}"
            break
        else
            print_status "ERROR" "âŒ Invalid selection. Try again."
        fi
    done

    # Get user inputs
    
    # VM Name
    while true; do
        read -p "$(print_status "INPUT" "ðŸ·ï¸  Enter VM name (default: $DEFAULT_HOSTNAME): ")" VM_NAME
        VM_NAME="${VM_NAME:-$DEFAULT_HOSTNAME}"
        if validate_input "name" "$VM_NAME"; then
            if [[ -f "$VM_DIR/$VM_NAME.conf" ]]; then
                print_status "ERROR" "âš ï¸  VM with name '$VM_NAME' already exists"
            else
                break
            fi
        fi
    done

    # Hostname (usually same as VM_NAME, but can be customized)
    HOSTNAME="$VM_NAME" 
    
    # Username
    while true; do
        read -p "$(print_status "INPUT" "ðŸ‘¤ Enter VM username (default: $DEFAULT_USERNAME): ")" USERNAME
        USERNAME="${USERNAME:-$DEFAULT_USERNAME}"
        if validate_input "username" "$USERNAME"; then
            break
        fi
    done

    # Password
    while true; do
        read -p "$(print_status "INPUT" "ðŸ”‘ Enter VM password (default: $DEFAULT_PASSWORD): ")" PASSWORD
        PASSWORD="${PASSWORD:-$DEFAULT_PASSWORD}"
        if [[ -n "$PASSWORD" ]]; then break; else print_status "ERROR" "âŒ Password cannot be empty"; fi
    done
    
    # Disk Size
    while true; do
        read -p "$(print_status "INPUT" "ðŸ’¾ Enter disk size (e.g., 20G, 100G) (default: 20G): ")" DISK_SIZE
        DISK_SIZE="${DISK_SIZE:-20G}"
        if validate_input "size" "$DISK_SIZE"; then break; fi
    done
    
    # Memory
    while true; do
        read -p "$(print_status "INPUT" "ðŸ§  Enter memory in MB (e.g., 2048, 4096) (default: 2048): ")" MEMORY
        MEMORY="${MEMORY:-2048}"
        if validate_input "number" "$MEMORY" && [ "$MEMORY" -ge 512 ]; then break; else print_status "ERROR" "âŒ Minimum 512MB"; fi
    done

    # CPUs
    while true; do
        read -p "$(print_status "INPUT" "âš¡ Enter CPU count (default: 2): ")" CPUS
        CPUS="${CPUS:-2}"
        if validate_input "number" "$CPUS" && [ "$CPUS" -ge 1 ]; then break; else print_status "ERROR" "âŒ Minimum 1 CPU"; fi
    done

    # SSH Port
    while true; do
        read -p "$(print_status "INPUT" "ðŸ”Œ Enter host SSH port for forward (e.g., 2222) (default: 2222): ")" SSH_PORT
        SSH_PORT="${SSH_PORT:-2222}"
        if validate_input "port" "$SSH_PORT"; then break; fi
    done
    
    # GUI Mode
    read -p "$(print_status "INPUT" "ðŸ–¥ï¸  Run with GUI/Desktop? (y/N): ")" gui_choice
    GUI_MODE=false
    if [[ "$gui_choice" =~ ^[Yy]$ ]]; then GUI_MODE=true; fi

    # Derived variables
    IMG_FILE="$VM_DIR/$VM_NAME.img"
    SEED_FILE="$VM_DIR/$VM_NAME-seed.iso"
    CREATED="$(date)"
    PORT_FORWARDS="" # Initialize, can be edited later

    # Download and setup VM image
    setup_vm_image
    
    # Save configuration
    save_vm_config
}

# Function to check if VM is running
is_vm_running() {
    local vm_name=$1
    
    if pgrep -f "qemu-system.*-name $vm_name" >/dev/null; then
        return 0
    fi
    
    return 1
}

# Function to stop a running VM
stop_vm() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        if is_vm_running "$vm_name"; then
            print_status "INFO" "ðŸ›‘ Stopping VM: $vm_name (Graceful Shutdown Attempt)"
            
            # Try graceful shutdown via pkill
            pkill -f "qemu-system.*-name $vm_name"
            sleep 3
            
            # Check if it stopped
            if is_vm_running "$vm_name"; then
                print_status "WARN" "âš ï¸  VM did not stop gracefully, forcing termination..."
                pkill -9 -f "qemu-system.*-name $vm_name"
                sleep 1
            fi
            
            # Clean up lock files (using the loaded IMG_FILE)
            rm -f "${IMG_FILE}.lock" 2>/dev/null
            
            if is_vm_running "$vm_name"; then
                print_status "ERROR" "âŒ Failed to stop VM"
                return 1
            else
                print_status "SUCCESS" "âœ… VM $vm_name stopped"
            fi
        else
            print_status "INFO" "ðŸ’¤ VM $vm_name is not running"
            # Still try to clean up any lock files just in case
            rm -f "${IMG_FILE}.lock" 2>/dev/null
        fi
    fi
}

# Function to start a VM
start_vm() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        
        # Check if VM is already running (check_image_lock handles process check/kill)
        if ! check_image_lock "$IMG_FILE" "$vm_name"; then
             print_status "ERROR" "ðŸš« Start failed: Image lock detected and not overridden."
             return 1
        fi
        
        print_status "INFO" "ðŸš€ Starting VM: $vm_name"
        print_status "INFO" "ðŸ”Œ SSH: ssh -p $SSH_PORT $USERNAME@localhost"
        print_status "INFO" "ðŸ”‘ Password: $PASSWORD"
        
        if [[ ! -f "$IMG_FILE" ]]; then
            print_status "ERROR" "âŒ VM image file not found: $IMG_FILE"
            return 1
        fi
        
        # Base QEMU command construction
        local qemu_cmd=(
            qemu-system-x86_64
            -name "$vm_name"
            -enable-kvm
            -m "$MEMORY"
            -smp "$CPUS"
            -cpu host
            -drive "file=$IMG_FILE,format=qcow2,if=virtio"
            -drive "file=$SEED_FILE,format=raw,if=virtio"
            -boot order=c
            -device virtio-net-pci,netdev=n0
            -netdev "user,id=n0,hostfwd=tcp::$SSH_PORT-:22"
        )

        # Add additional port forwards (if configured)
        if [[ -n "$PORT_FORWARDS" ]]; then
            IFS=',' read -ra forwards <<< "$PORT_FORWARDS"
            local net_id=1
            for forward in "${forwards[@]}"; do
                IFS=':' read -r host_port guest_port <<< "$forward"
                qemu_cmd+=(-device "virtio-net-pci,netdev=n${net_id}")
                qemu_cmd+=(-netdev "user,id=n${net_id},hostfwd=tcp::$host_port-:$guest_port")
                ((net_id++))
            done
        fi

        # Add GUI or console mode
        if [[ "$GUI_MODE" == true ]]; then
            qemu_cmd+=(-vga virtio -display gtk,gl=on)
            print_status "INFO" "ðŸ–¥ï¸  Starting in GUI mode..."
        else
            qemu_cmd+=(-nographic -serial mon:stdio)
            print_status "INFO" "ðŸ“Ÿ Starting in console mode (Press Ctrl+A then X to exit QEMU console)"
        fi

        # Add performance enhancements
        qemu_cmd+=(
            -device virtio-balloon-pci
            -object rng-random,filename=/dev/urandom,id=rng0
            -device virtio-rng-pci,rng=rng0
        )

        print_status "INFO" "âš¡ Launching QEMU..."
        echo "ðŸ“Š Configuration: ${MEMORY}MB RAM, ${CPUS} CPUs, ${DISK_SIZE} disk"
        
        # Start the VM in the background if using console, or foreground if using GUI
        if [[ "$GUI_MODE" == false ]]; then
             # Execute the command in the foreground so the console output is visible
             # Trap exit signals to ensure cleanup occurs properly
             if ! "${qemu_cmd[@]}"; then
                 print_status "ERROR" "âŒ Failed to start VM. Check QEMU/KVM setup."
                 rm -f "${IMG_FILE}.lock" 2>/dev/null
                 return 1
             fi
        else
             # Execute GUI mode in the background
             # shellcheck disable=SC2048,SC2086
             if ! "${qemu_cmd[@]}" &
             then
                 print_status "ERROR" "âŒ Failed to start VM in GUI mode."
                 rm -f "${IMG_FILE}.lock" 2>/dev/null
                 return 1
             fi
             print_status "SUCCESS" "âœ… VM started in background GUI mode."
             # Wait a moment before returning to the menu
             sleep 5
        fi
        
        print_status "INFO" "ðŸ›‘ VM $vm_name has been shut down or exited"
    fi
}

# Function to delete a VM
delete_vm() {
    local vm_name=$1
    
    print_status "WARN" "âš ï¸  âš ï¸  âš ï¸  This will permanently delete VM '$vm_name' and all its data!"
    read -p "$(print_status "INPUT" "ðŸ—‘ï¸  Are you sure? (y/N): ")" -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        if load_vm_config "$vm_name"; then
            if is_vm_running "$vm_name"; then
                print_status "WARN" "âš ï¸  VM is currently running. Stopping it first..."
                stop_vm "$vm_name"
                sleep 2
            fi
            
            # Delete files
            rm -f "$IMG_FILE" "$SEED_FILE" "$VM_DIR/$vm_name.conf" "${IMG_FILE}.lock" 2>/dev/null
            
            # Check for CoW base image if it was created
            local base_img="$VM_DIR/$vm_name-base.img"
            if [[ -f "$base_img" ]]; then
                print_status "INFO" "ðŸ—‘ï¸  Deleting base image: $base_img"
                rm -f "$base_img" 2>/dev/null
            fi
            
            print_status "SUCCESS" "âœ… VM '$vm_name' has been deleted"
        fi
    else
        print_status "INFO" "ðŸ‘ Deletion cancelled"
    fi
}

# Function to show VM info
show_vm_info() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        echo
        print_status "INFO" "ðŸ“Š VM Information: $vm_name"
        echo "ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹"
        echo "ðŸŒ OS: $OS_TYPE"
        echo "ðŸ·ï¸  Hostname: $HOSTNAME"
        echo "ðŸ‘¤ Username: $USERNAME"
        echo "ðŸ”‘ Password: $PASSWORD"
        echo "ðŸ”Œ SSH Port: $SSH_PORT"
        echo "ðŸ§  Memory: $MEMORY MB"
        echo "âš¡ CPUs: $CPUS"
        echo "ðŸ’¾ Disk: $DISK_SIZE"
        echo "ðŸ–¥ï¸  GUI Mode: $GUI_MODE"
        echo "ðŸŒ Port Forwards: ${PORT_FORWARDS:-None}"
        echo "ðŸ“… Created: $CREATED"
        echo "ðŸ’¿ Image File: $IMG_FILE"
        echo "ðŸŒ± Seed File: $SEED_FILE"
        
        # Show lock status
        if check_image_lock "$IMG_FILE" "$vm_name" >/dev/null 2>&1; then
            echo "ðŸ”“ Image Status: Unlocked"
        else
            echo "ðŸ”’ Image Status: Locked (possibly in use)"
        fi
        
        # Show if VM is running
        if is_vm_running "$vm_name"; then
            echo "ðŸš€ Status: Running (PID: $(pgrep -f "qemu-system.*-name $vm_name" | head -1))"
        else
            echo "ðŸ’¤ Status: Stopped"
        fi
        
        echo "ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹"
        echo
        read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
    fi
}

# Function to edit VM configuration
edit_vm_config() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        print_status "INFO" "âœï¸  Editing VM: $vm_name"
        
        while true; do
            echo "ðŸ“ What would you like to edit?"
            echo "  1) ðŸ·ï¸  Hostname (Current: $HOSTNAME)"
            echo "  2) ðŸ‘¤ Username (Current: $USERNAME)"
            echo "  3) ðŸ”‘ Password (Current: Hidden)"
            echo "  4) ðŸ”Œ SSH Port (Current: $SSH_PORT)"
            echo "  5) ðŸ–¥ï¸  GUI Mode (Current: $GUI_MODE)"
            echo "  6) ðŸŒ Port Forwards (Current: ${PORT_FORWARDS:-None})"
            echo "  7) ðŸ§  Memory (RAM) (Current: $MEMORY MB)"
            echo "  8) âš¡ CPU Count (Current: $CPUS)"
            echo "  0) â†©ï¸  Back to VM menu"
            
            read -p "$(print_status "INPUT" "ðŸŽ¯ Enter your choice: ")" edit_choice
            
            local config_changed=false
            
            case $edit_choice in
                1)
                    while true; do
                        read -p "$(print_status "INPUT" "ðŸ·ï¸  Enter new hostname: ")" new_hostname
                        new_hostname="${new_hostname:-$HOSTNAME}"
                        if validate_input "name" "$new_hostname"; then
                            if [[ "$HOSTNAME" != "$new_hostname" ]]; then HOSTNAME="$new_hostname"; config_changed=true; fi
                            break
                        fi
                    done
                    ;;
                2)
                    while true; do
                        read -p "$(print_status "INPUT" "ðŸ‘¤ Enter new username: ")" new_username
                        new_username="${new_username:-$USERNAME}"
                        if validate_input "username" "$new_username"; then
                            if [[ "$USERNAME" != "$new_username" ]]; then USERNAME="$new_username"; config_changed=true; fi
                            break
                        fi
                    done
                    ;;
                3)
                    read -p "$(print_status "INPUT" "ðŸ”‘ Enter new password (leave blank to keep current): ")" new_password
                    if [[ -n "$new_password" ]]; then
                        PASSWORD="$new_password"
                        config_changed=true
                    fi
                    ;;
                4)
                    while true; do
                        read -p "$(print_status "INPUT" "ðŸ”Œ Enter new host SSH port: ")" new_ssh_port
                        new_ssh_port="${new_ssh_port:-$SSH_PORT}"
                        if validate_input "port" "$new_ssh_port"; then
                            if [[ "$SSH_PORT" != "$new_ssh_port" ]]; then SSH_PORT="$new_ssh_port"; config_changed=true; fi
                            break
                        fi
                    done
                    ;;
                5)
                    read -p "$(print_status "INPUT" "ðŸ–¥ï¸  Enable GUI? (y/N) (Current: $GUI_MODE): ")" gui_choice
                    if [[ "$gui_choice" =~ ^[Yy]$ ]]; then new_gui=true; else new_gui=false; fi
                    if [[ "$GUI_MODE" != "$new_gui" ]]; then GUI_MODE="$new_gui"; config_changed=true; fi
                    ;;
                6)
                    read -p "$(print_status "INPUT" "ðŸŒ Enter new port forwards (e.g., 8080:80,8443:443) (Current: ${PORT_FORWARDS:-None}): ")" new_forwards
                    if [[ "$PORT_FORWARDS" != "$new_forwards" ]]; then PORT_FORWARDS="$new_forwards"; config_changed=true; fi
                    ;;
                7)
                    while true; do
                        read -p "$(print_status "INPUT" "ðŸ§  Enter new memory in MB (current: $MEMORY): ")" new_memory
                        new_memory="${new_memory:-$MEMORY}"
                        if validate_input "number" "$new_memory" && [ "$new_memory" -ge 512 ]; then 
                            if [[ "$MEMORY" != "$new_memory" ]]; then MEMORY="$new_memory"; config_changed=true; fi
                            break
                        else
                             print_status "ERROR" "âŒ Minimum 512MB"
                        fi
                    done
                    ;;
                8)
                    while true; do
                        read -p "$(print_status "INPUT" "âš¡ Enter new CPU count (current: $CPUS): ")" new_cpus
                        new_cpus="${new_cpus:-$CPUS}"
                        if validate_input "number" "$new_cpus" && [ "$new_cpus" -ge 1 ]; then 
                            if [[ "$CPUS" != "$new_cpus" ]]; then CPUS="$new_cpus"; config_changed=true; fi
                            break
                        else
                            print_status "ERROR" "âŒ Minimum 1 CPU"
                        fi
                    done
                    ;;
                0) return 0 ;;
                *) print_status "ERROR" "âŒ Invalid selection" ;;
            esac
            
            if [[ "$config_changed" == true ]]; then
                # Recreate seed image if user/password/hostname changed
                if [[ "$edit_choice" -le 3 ]]; then
                    print_status "INFO" "ðŸ”„ Updating cloud-init configuration..."
                    setup_vm_image
                fi
                
                save_vm_config
                print_status "SUCCESS" "âœ… Configuration updated."
            else
                print_status "INFO" "â„¹ï¸  No changes detected."
            fi
            
            read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
            display_header
            print_status "INFO" "âœï¸  Editing VM: $vm_name"
        done
    fi
}

# Function to resize VM disk
resize_vm_disk() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        if is_vm_running "$vm_name"; then
            print_status "ERROR" "âŒ Cannot resize disk while VM is running. Please stop the VM first."
            return 1
        fi
        
        print_status "INFO" "ðŸ’¾ Current disk size: $DISK_SIZE"
        
        while true; do
            read -p "$(print_status "INPUT" "ðŸ“ˆ Enter new disk size (e.g., 50G): ")" new_disk_size
            if validate_input "size" "$new_disk_size"; then
                
                # Check if it's smaller (qemu-img won't shrink unless forced, which risks data loss)
                local current_bytes=$(qemu-img info "$IMG_FILE" | grep 'virtual size' | awk '{print $NF}' | tr -d '()')
                
                # Simple check for safety: ensure the new size isn't drastically smaller
                local new_bytes_unit=$(echo "$new_disk_size" | tr -d '[:alpha:]')
                local new_unit=$(echo "$new_disk_size" | tr -d '[:digit:]' | tr '[:lower:]' '[:upper:]')
                local multiplier=1
                
                if [[ "$new_unit" == "M" ]]; then multiplier=1048576; fi
                if [[ "$new_unit" == "G" ]]; then multiplier=1073741824; fi

                local new_bytes=$(( new_bytes_unit * multiplier ))
                
                if [ "$new_bytes" -lt "$current_bytes" ]; then
                     print_status "WARN" "âš ï¸  Shrinking disk ($DISK_SIZE -> $new_disk_size) may cause data loss. Proceed only if you have shrunk the partition inside the VM first!"
                     read -p "$(print_status "INPUT" "ðŸ”„ I have shrunk the internal partition. Proceed? (y/N): ")" shrink_confirm
                     if [[ ! "$shrink_confirm" =~ ^[Yy]$ ]]; then
                         print_status "INFO" "ðŸ‘ Resize cancelled."
                         return 0
                     fi
                fi
                
                print_status "INFO" "ðŸ“ˆ Resizing disk to $new_disk_size..."
                if qemu-img resize "$IMG_FILE" "$new_disk_size"; then
                    DISK_SIZE="$new_disk_size"
                    save_vm_config
                    print_status "SUCCESS" "âœ… Disk resized successfully to $new_disk_size (Internal partition resize may be required on next boot)."
                else
                    print_status "ERROR" "âŒ Failed to resize disk"
                    return 1
                fi
                break
            fi
        done
    fi
}

# Function to fix VM issues
fix_vm_issues() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        display_header
        print_status "INFO" "ðŸ”§ Fixing issues for VM: $vm_name"
        
        while true; do
            echo "ðŸ”§ Select issue to fix:"
            echo "  1) ðŸ”“ Remove lock files"
            echo "  2) ðŸŒ± Recreate cloud-init seed image (if user/network config failed)"
            echo "  3) ðŸ“ˆ Show Performance Metrics" # Moved here for easy access
            echo "  0) â†©ï¸  Back to VM menu"
            
            read -p "$(print_status "INPUT" "ðŸŽ¯ Enter your choice: ")" fix_choice
            
            case $fix_choice in
                1)
                    if [[ -f "${IMG_FILE}.lock" ]]; then
                        rm -f "${IMG_FILE}.lock" 2>/dev/null
                        print_status "SUCCESS" "âœ… Removed lock file: ${IMG_FILE}.lock"
                    else
                        print_status "INFO" "â„¹ï¸  No lock file found to remove."
                    fi
                    ;;
                2)
                    print_status "INFO" "ðŸ”„ Recreating cloud-init seed image..."
                    # Use current VM_NAME, HOSTNAME, USERNAME, and PASSWORD from loaded config
                    setup_vm_image
                    print_status "SUCCESS" "âœ… Seed image recreated. Restart VM for changes to take effect."
                    ;;
                3)
                    show_vm_performance "$vm_name"
                    ;;
                0)
                    break
                    ;;
                *)
                    print_status "ERROR" "âŒ Invalid selection"
                    ;;
            esac
            read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
            display_header
            print_status "INFO" "ðŸ”§ Fixing issues for VM: $vm_name"
        done
    fi
}

# Function to show VM performance metrics
show_vm_performance() {
    local vm_name=$1
    
    if load_vm_config "$vm_name"; then
        display_header
        print_status "INFO" "ðŸ“Š Performance metrics for VM: $vm_name"
        echo "ðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆ"
        
        if is_vm_running "$vm_name"; then
            local qemu_pid=$(pgrep -f "qemu-system.*-name $vm_name" | head -1)
            if [[ -n "$qemu_pid" ]]; then
                echo "âš¡ QEMU Process Stats (PID $qemu_pid):"
                # Display CPU, Memory usage, and command line
                ps -p "$qemu_pid" -o pid,%cpu,%mem,sz,rss,vsz,cmd --no-headers
            else
                print_status "WARN" "âš ï¸  QEMU process not found by PID."
            end
        else
            print_status "WARN" "ðŸ’¤ VM is stopped. No live metrics available."
        fi
        
        echo "ðŸ’¾ Disk Usage:"
        # Show actual disk usage of the file
        du -h "$IMG_FILE" 2>/dev/null || print_status "WARN" "âš ï¸  Disk image file not found."
        
        echo "ðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆðŸ“ˆ"
        read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
    fi
}


# Function to manage a selected VM
vm_management_menu() {
    local vm_name=$1
    
    while true; do
        load_vm_config "$vm_name" # Reload config in case of edits
        display_header
        print_status "INFO" "ðŸš€ Managing VM: $vm_name"
        echo "ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹"
        
        # Check if running and show status
        if is_vm_running "$vm_name"; then
            print_status "SUCCESS" "ðŸš€ Status: Running (PID: $(pgrep -f "qemu-system.*-name $vm_name" | head -1))"
            local run_text="ðŸ›‘ Stop VM"
        else
            print_status "WARN" "ðŸ’¤ Status: Stopped"
            local run_text="ðŸš€ Start VM"
        fi
        
        echo "ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹ðŸ”¹"
        
        echo "  1) $run_text"
        echo "  2) ðŸ“Š Show Info"
        echo "  3) âœï¸  Edit Configuration"
        echo "  4) ðŸ’¾ Resize Disk Image"
        echo "  5) ðŸ”§ Fix Common Issues / Metrics"
        echo "  6) ðŸ—‘ï¸  Delete VM (Permanent)"
        echo "  0) â†©ï¸  Back to Main Menu"
        
        read -p "$(print_status "INPUT" "ðŸŽ¯ Enter your choice: ")" action_choice
        
        display_header # Clear screen before running action
        
        case $action_choice in
            1)
                if is_vm_running "$vm_name"; then
                    stop_vm "$vm_name"
                else
                    start_vm "$vm_name"
                fi
                read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
                ;;
            2) show_vm_info "$vm_name" ;;
            3) edit_vm_config "$vm_name" ;;
            4) resize_vm_disk "$vm_name" ;;
            5) fix_vm_issues "$vm_name" ;;
            6) 
                delete_vm "$vm_name"
                return # Exit back to main menu after deletion
                ;;
            0) return ;;
            *) print_status "ERROR" "âŒ Invalid selection"
               read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
               ;;
        esac
    done
}

# --- Main Program Entry Point ---
main_menu() {
    # 1. Dependency check runs first
    check_dependencies
    
    # 2. Ensure VM directory exists
    mkdir -p "$VM_DIR" 2>/dev/null

    while true; do
        display_header
        
        print_status "INFO" "ðŸ“¦ VM Directory: $VM_DIR"
        echo "========================================================================"
        echo "                      M A I N   M E N U"
        echo "========================================================================"
        
        echo "  1) ðŸ†• Create New VM"
        echo "  2) ðŸš€ Manage Existing VM"
        echo "  0) âŒ Exit"
        echo
        
        read -p "$(print_status "INPUT" "ðŸŽ¯ Enter your choice: ")" main_choice
        
        case $main_choice in
            1)
                display_header
                create_new_vm
                read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
                cleanup
                ;;
            2)
                local vm_list=$(get_vm_list)
                if [[ -z "$vm_list" ]]; then
                    print_status "WARN" "âš ï¸  No VMs found in $VM_DIR. Create one first."
                    read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
                    continue
                fi
                
                display_header
                print_status "INFO" "ðŸŒ Select a VM to manage:"
                local i=1
                local selected_vms=()
                
                # Show list of existing VMs
                while IFS= read -r vm; do
                    echo "  $i) $vm"
                    selected_vms[$i]="$vm"
                    ((i++))
                done <<< "$vm_list"

                echo "  0) â†©ï¸  Back to Main Menu"
                
                local vm_count=$((i-1))
                while true; do
                    read -p "$(print_status "INPUT" "ðŸŽ¯ Enter VM number (1-$vm_count) or 0: ")" vm_choice
                    if [[ "$vm_choice" =~ ^[0-9]+$ ]] && [ "$vm_choice" -ge 0 ] && [ "$vm_choice" -le "$vm_count" ]; then
                        if [ "$vm_choice" -eq 0 ]; then
                            break
                        fi
                        local selected_vm="${selected_vms[$vm_choice]}"
                        vm_management_menu "$selected_vm"
                        break
                    else
                        print_status "ERROR" "âŒ Invalid selection. Try again."
                    fi
                done
                ;;
            0)
                print_status "INFO" "ðŸ‘‹ Exiting VM Manager. Goodbye!"
                exit 0
                ;;
            *)
                print_status "ERROR" "âŒ Invalid selection"
                read -p "$(print_status "INPUT" "âŽ Press Enter to continue...")"
                ;;
        esac
    done
}

# --- Execute Main Program ---
main_menu
